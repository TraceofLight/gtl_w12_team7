# 상하체 분리 기능 구현 계획서

## 1. 개요

본 문서는 Mundi 엔진의 애니메이션 시스템에 **상하체 분리(Upper/Lower Body Separation)** 기능을 추가하기 위한 구체적인 구현 계획을 기술합니다. 프로젝트에 이미 존재하는 `AnimationSystem_Architecture.md` 문서를 기반으로, 설계는 되어 있으나 아직 구현되지 않은 `FAnimNode_LayerBlend` 클래스를 핵심적으로 구현합니다.

## 2. 목표

- 캐릭터가 하체 애니메이션(예: 걷기, 뛰기)과 상체 애니메이션(예: 조준, 공격, 물건 들기)을 독립적으로 재생하고 자연스럽게 조합할 수 있도록 한다.
- `BlendSpace2D`와 연동하여, 이동 방향에 따라 하체는 블렌딩되면서 상체는 고정된 자세를 유지하는 기능을 구현한다.

## 3. 핵심 구현 요소: `FAnimNode_LayerBlend`

상하체 분리는 `FAnimNode_LayerBlend` 라는 새로운 애니메이션 노드를 통해 구현됩니다.

- **역할**: 두 개의 입력 포즈(Base, Overlay)를 하나의 출력 포즈로 합칩니다.
- **입력**:
    1.  `Base Layer Pose`: 전신(주로 하체)의 움직임을 담당하는 포즈.
    2.  `Overlay Layer Pose`: 덮어씌울 상체의 움직임을 담당하는 포즈.
- **로직**: 특정 뼈(Spine)를 기준으로, 그 뼈의 모든 자식 뼈(상체)에 대해 `Overlay Layer Pose`의 로컬 변환 값을 그대로 복사합니다. `Base Layer Pose`의 나머지 뼈(하체) 정보는 유지됩니다.

## 4. 구체적인 구현 단계

### 1단계: `FAnimNode_LayerBlend` 클래스 파일 생성

- **경로**: `Mundi/Source/Runtime/Engine/Animation/`
- **생성 파일**:
    1.  `AnimNode_LayerBlend.h` (헤더 파일)
    2.  `AnimNode_LayerBlend.cpp` (소스 파일)

#### `AnimNode_LayerBlend.h` 예상 코드
```cpp
#pragma once

#include "AnimNode_Base.h"

// FAnimNode_LayerBlend: 두 애니메이션 레이어를 특정 뼈를 기준으로 블렌딩합니다.
class FAnimNode_LayerBlend : public FAnimNode_Base
{
public:
    FAnimNode_LayerBlend();

    // FAnimNode_Base 인터페이스
    virtual void Initialize(const FAnimationUpdateContext& Context) override;
    virtual void Update(const FAnimationUpdateContext& Context) override;
    virtual void Evaluate(FPoseContext& Output) override;

    // 입력 핀 설정
    void SetBaseLayer(FAnimNode_Base* InBaseLayer) { BaseLayer = InBaseLayer; }
    void SetOverlayLayer(FAnimNode_Base* InOverlayLayer) { OverlayLayer = InOverlayLayer; }

    // 블렌딩 기준이 될 뼈 이름 설정
    void SetSpineBoneName(const FName& InBoneName) { SpineBoneName = InBoneName; }

private:
    // 하체 및 전신 애니메이션을 위한 입력
    FAnimNode_Base* BaseLayer = nullptr;

    // 상체 오버레이 애니메이션을 위한 입력
    FAnimNode_Base* OverlayLayer = nullptr;

    // 블렌딩 기준 뼈 (예: "spine_01")
    FName SpineBoneName;

    // 최적화를 위해 계산해두는 뼈 인덱스
    int32 SpineBoneIndex = -1;
    TArray<int32> UpperBodyBoneIndices;

    // 해골(Skeleton) 애셋에 따라 상체 뼈 인덱스를 미리 계산하는 함수
    void CalculateUpperBodyBoneIndices(const USkeleton* InSkeleton);
};
```

#### `AnimNode_LayerBlend.cpp` 예상 코드
```cpp
#include "AnimNode_LayerBlend.h"
#include "Animation/Skeleton.h"

// ... (생성자, Initialize, Update 구현) ...

void FAnimNode_LayerBlend::Evaluate(FPoseContext& Output)
{
    if (!BaseLayer || !OverlayLayer || SpineBoneIndex == -1)
    {
        // 입력이 없거나 뼈 설정이 잘못되면 BaseLayer만 평가
        if(BaseLayer) BaseLayer->Evaluate(Output);
        return;
    }

    // 1. BaseLayer (하체) 포즈를 먼저 계산
    BaseLayer->Evaluate(Output);

    // 2. OverlayLayer (상체) 포즈를 별도의 컨텍스트에 계산
    FPoseContext OverlayPoseContext(Output.AnimInstance);
    OverlayLayer->Evaluate(OverlayPoseContext);

    // 3. 상체 뼈들에 대해 Overlay 포즈를 덮어쓰기
    // 기준 뼈 자체도 포함
    Output.Pose[SpineBoneIndex] = OverlayPoseContext.Pose[SpineBoneIndex];

    // 모든 상체 자식 뼈들에 대해 복사
    for (int32 BoneIndex : UpperBodyBoneIndices)
    {
        Output.Pose[BoneIndex] = OverlayPoseContext.Pose[BoneIndex];
    }
}

void FAnimNode_LayerBlend::CalculateUpperBodyBoneIndices(const USkeleton* InSkeleton)
{
    if (!InSkeleton) return;

    SpineBoneIndex = InSkeleton->GetBoneIndex(SpineBoneName);
    if (SpineBoneIndex == -1) return; // 뼈를 찾지 못함

    UpperBodyBoneIndices.Empty();
    TArray<int32> BonesToProcess;
    BonesToProcess.Add(SpineBoneIndex);

    // BFS/DFS 방식으로 모든 자식 뼈 검색
    while(BonesToProcess.Num() > 0)
    {
        int32 CurrentBone = BonesToProcess.Pop();
        for (int32 ChildIndex : InSkeleton->GetChildBoneIndices(CurrentBone))
        {
            UpperBodyBoneIndices.Add(ChildIndex);
            BonesToProcess.Add(ChildIndex);
        }
    }
}
```

### 2단계: 애니메이션 인스턴스(AnimInstance) 수정

애니메이션 실행을 총괄하는 `UAnimInstance`의 파생 클래스(예: `UMyCharacterAnimInstance`)에 `FAnimNode_LayerBlend` 노드를 추가하고 연결합니다.

#### `MyCharacterAnimInstance.h` 예상 수정
```cpp
#include "Animation/AnimInstance.h"
#include "AnimNode_StateMachine.h"
#include "AnimNode_BlendSpace2D.h"
#include "AnimNode_LayerBlend.h" // 새로 추가
#include "MyCharacterAnimInstance.generated.h"

UCLASS()
class UMyCharacterAnimInstance : public UAnimInstance
{
    GENERATED_BODY()

protected:
    // 하체 이동을 위한 블렌드 스페이스
    UPROPERTY(EditAnywhere, Category = "Animation")
    UBlendSpace2D* LocomotionBlendSpace;

    // 상체 조준을 위한 블렌드 스페이스
    UPROPERTY(EditAnywhere, Category = "Animation")
    UBlendSpace2D* AimingBlendSpace;

    // 실행 노드들
    FAnimNode_BlendSpace2D Locomotion_BS_Node;
    FAnimNode_BlendSpace2D Aiming_BS_Node;
    FAnimNode_LayerBlend UpperBodyBlendNode; // 레이어 블렌드 노드

public:
    virtual void Initialize() override;
    virtual void Update(float DeltaSeconds) override;

private:
    // 루트 노드 (최종 결과물)
    FAnimNode_Base* RootNode = nullptr;
};
```

#### `MyCharacterAnimInstance.cpp` 예상 수정
```cpp
#include "MyCharacterAnimInstance.h"

void UMyCharacterAnimInstance::Initialize()
{
    Super::Initialize();

    // 1. 하체 블렌드 스페이스 노드 설정
    Locomotion_BS_Node.SetBlendSpace(LocomotionBlendSpace);

    // 2. 상체 블렌드 스페이스 노드 설정
    Aiming_BS_Node.SetBlendSpace(AimingBlendSpace);

    // 3. 레이어 블렌드 노드 설정
    UpperBodyBlendNode.SetBaseLayer(&Locomotion_BS_Node);
    UpperBodyBlendNode.SetOverlayLayer(&Aiming_BS_Node);
    UpperBodyBlendNode.SetSpineBoneName("spine_01"); // 실제 스켈레톤에 맞는 뼈 이름 사용

    // 4. 최종 출력 노드를 레이어 블렌드 노드로 지정
    RootNode = &UpperBodyBlendNode;
    RootNode->Initialize(*this);
}

void UMyCharacterAnimInstance::Update(float DeltaSeconds)
{
    Super::Update(DeltaSeconds);

    // 캐릭터의 속도, 조준 각도 등의 파라미터를 가져와서
    // 각 블렌드 스페이스 노드에 전달
    FVector2D LocomotionParams = GetLocomotionParameters(); // (Speed, Direction)
    Locomotion_BS_Node.SetBlendParameters(LocomotionParams);

    FVector2D AimingParams = GetAimingParameters(); // (AimYaw, AimPitch)
    Aiming_BS_Node.SetBlendParameters(AimingParams);

    // 루트 노드부터 전체 애니메이션 그래프 업데이트
    if (RootNode)
    {
        RootNode->Update(DeltaSeconds);
    }
}

// Evaluate는 RootNode->Evaluate()를 호출하여 최종 포즈를 계산 (엔진 레벨에서 처리)
```

## 5. 예상 리스크 및 해결 방안

- **리스크**: 스켈레톤의 뼈 구조가 복잡하거나, 기준 뼈(`SpineBoneName`) 설정이 잘못될 경우 원치 않는 부위가 블렌딩될 수 있음.
- **해결**: 스켈레톤 에디터나 디버깅 기능을 통해 뼈의 이름과 계층 구조를 명확히 확인하고 설정해야 함. 디버그 렌더링으로 각 뼈의 변환 값을 시각화하는 기능이 도움이 될 수 있음.

- **리스크**: `BaseLayer`와 `OverlayLayer` 애니메이션 간의 키 차이로 인해 특정 뼈가 늘어나거나(stretching) 비틀리는(twisting) 현상.
- **해결**: 애니메이션 원본 데이터를 수정하여 유사한 기본 포즈를 갖도록 하거나, 블렌딩 시 회전(Rotation)만 복사하고 위치(Translation)는 `BaseLayer` 것을 유지하는 등의 추가 옵션을 `FAnimNode_LayerBlend`에 구현하는 것을 고려. (초기 구현에서는 로컬 변환 전체를 복사)

## 6. 결론

위에 제시된 단계에 따라 `FAnimNode_LayerBlend`를 구현하고 `AnimInstance`에 통합함으로써, 프로젝트의 기존 아키텍처를 최대한 활용하여 효율적으로 상하체 분리 기능을 완성할 수 있습니다.
